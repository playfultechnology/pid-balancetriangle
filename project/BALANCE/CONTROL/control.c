#include "control.h"	
#include "filter.h"
#include "show.h"
#include "usart.h"
#include "stmflash.h"
#include "led.h"

float Energy_Storage=0.45;          //刹车前蓄能的惯量轮速度系数，数值越大，刹车前惯量轮转速越高，起立动量越大
float Center_Gravity;               //机械中值
float Center_Gra_Sart=88.9;         //开机设定机械中值
int Encoder_x=0;              //编码器读数
int Moto_x;                   //电机PWM变量	
int Voltage;                  //电池电压变量
float Angle_Balance_x;        //横向角度
float Gyro_Balance_x=0;       //横向角加速度


static float Bias,Pwm,Last_bias;      //偏差、控制变量、上一次偏差

static float Pwm_L,Integral_bias_L,Last_Bias_L,Encoder_L;

int Balance_Pwm_x=0,velocity_Pwm_x=0; //横向电机PWM分量
char t=0;                             //状态变量
int s=0;                              //上电稳定变量                    
int TIM1_UP_IRQHandler(void)          //所有的控制代码都在这里面 TIM1控制的10ms定时中断  
{    
	if(TIM1->SR&0X0001)
	{   
		  u8 key_value;
		  TIM1->SR&=~(1<<0);                     //===清除定时器1中断标志位
      Get_Angle();                           //获取角度
		  Voltage=Get_battery_volt()*1000;       //获取电压
      Encoder_x=-Read_Encoder(2);            //更新编码器位置信息
//      if(s<100)s++;                        //上电不稳定状态
//      else                                 //上电稳定状态
			{				
				if(Angle_Balance_x>120)Pwm_L=Integral_bias_L=Last_Bias_L=Encoder_L=0,left_up();      //左起立程序
				else if(Angle_Balance_x<60)Pwm_L=Integral_bias_L=Last_Bias_L=Encoder_L=0,Right_up(); //右起立程序
				else nomal();                          //维持直立状态
				Set_Pwm(Moto_x);                       //===赋值给PWM寄存器*/	
			}
			key_value=key_read();
			if(key_value==3)                         //两个按键同时被按下，进入参数调节状态
			{
				Set_Pwm(0);                            //关闭电机
				while(key_value==3)key_value=key_read();
				fill_picture(0x00);	            //OLED清屏
				OLED_ShowString(5,10,"SET_UP",12);
			  OLED_ShowString(10,4,"Entering...",12);					
				delay_ms(1000);
				fill_picture(0x00);	            //OLED清屏
				while(1)
				{
					Get_Angle();                           //获取角度
		      Voltage=Get_battery_volt();            //获取电压
          Encoder_x=-Read_Encoder(2);             //更新编码器位置信息
					key_value=key_read();
					if(Angle_Balance_x<70||Angle_Balance_x>110)
					{
						if(key_value==1)
						{
							if(Angle_Balance_x<70)Center_Gra_Sart=Center_Gra_Sart-0.1;
							else if(Angle_Balance_x>110)Center_Gra_Sart=Center_Gra_Sart+0.1;
							oled_show(); 
							delay_ms(200);				
						}
						else if(key_value==2)
						{
							if(Angle_Balance_x<70)Energy_Storage=Energy_Storage-0.01;
							else if(Angle_Balance_x>110)Energy_Storage=Energy_Storage+0.01;
							if(Energy_Storage>0.6)Energy_Storage=0.6;
							oled_show(); 
							delay_ms(200);
						}
				  }
					else if(key_value==3)
					{
						fill_picture(0x00);	            //OLED清屏
						OLED_ShowString(5,3,"Parameters",12);
						OLED_ShowString(10,4,"Saving...",12);
            datatemp[0]=((int)(Center_Gra_Sart*10))/100;
					  datatemp[1]=(((int)(Center_Gra_Sart*10))%100)/10;
					  datatemp[2]=((int)(Center_Gra_Sart*10))%10;
						datatemp[3]=((int)(Energy_Storage*100))/100;
						datatemp[4]=(((int)(Energy_Storage*100))%100)/10;
						datatemp[5]=((int)(Energy_Storage*100))%10;
					  STMFLASH_Write(FLASH_SAVE_ADDR,(u16*)datatemp,7);						
						delay_ms(1000);delay_ms(1000);
						fill_picture(0x00);	            //OLED清屏
						break;
					}
					oled_show(); 
					delay_ms(5);
				}
			}
	
	
	}       	
	 return 0;	  
} 
void left_up()
{
  if(t==0)t=1;	
	if(t==1)                                                     //第一阶段：读取稳定角度
	{
		static float angle_last;
		float angle_bias;      //角度变化量
		angle_bias*=0.8;
		angle_bias+=(angle_last-Angle_Balance_x)*0.2;//一阶滤波
		if(angle_bias<0.01||angle_bias>-0.01)t=2;    //若角度变化量很小了，说明角度已稳定
		angle_last=Angle_Balance_x;
	}
	else if(t==2)                                                //第二阶段：根据倒下的角度确定惯量轮旋转的速度
	{
		float speed_target,speed_bias;
		speed_target=Angle_Balance_x-90.0;
		Moto_x=Incremental_PI (-Encoder_x,speed_target*Energy_Storage);
		speed_bias=speed_target*Energy_Storage-Encoder_x; 
		if(speed_bias<3&&speed_bias>-3)t=3,Bias=Pwm=Last_bias=0;    //若速度变化量很小了，说明速度已稳定
	}
	else if(t==3)                                                //第三阶段：刹车起立
	{		
		int i=0; 	
    while(Angle_Balance_x>105)      //到达角度平衡
		{
		 Encoder_x=-Read_Encoder(2);             //更新编码器位置信息
		 Moto_x=Encoder_x*240*8;             //反向施加力矩
     Set_Pwm(Moto_x); 		
		 Get_Angle();
     delay_ms(5);			
		 i++;
		 if(i>400)break;   //超时未起立，起立失败
	  }
		t=0;
  }
}
void Right_up()
{
	if(t==0)t=11;	
	if(t==11)                                                     //第一阶段：读取稳定角度
	{
		static float angle_last;
		float angle_bias;      //角度变化量
		angle_bias*=0.8;
		angle_bias+=(angle_last-Angle_Balance_x)*0.2;//一阶滤波
		if(angle_bias<0.01||angle_bias>-0.01)t=12;    //若角度变化量很小了，说明角度已稳定
		angle_last=Angle_Balance_x;
	}
	else if(t==12)                                                //第二阶段：根据倒下的角度确定惯量轮旋转的速度
	{
		float speed_target,speed_bias;
		speed_target=Angle_Balance_x-90.0;
		Moto_x=Incremental_PI (-Encoder_x,speed_target*Energy_Storage);
		speed_bias=speed_target*Energy_Storage-Encoder_x; 
		if(speed_bias<3&&speed_bias>-3)t=13,Bias=Pwm=Last_bias=0;    //若速度变化量很小了，说明速度已稳定
	}
	else if(t==13)                                                //第三阶段：刹车起立
	{		
		int i=0; 	
    while(Angle_Balance_x<75)      //到达角度平衡
		{
		 Encoder_x=-Read_Encoder(2);             //更新编码器位置信息
		 Moto_x=Encoder_x*240*8;             //反向施加力矩
     Set_Pwm(Moto_x); 			
		 Get_Angle();
     delay_ms(5);			
		 i++;
		 if(i>400)break;   //超时未起立，起立失败
	  }
		t=0;
  }
}
void nomal()
{
      if(Encoder_x>10)Center_Gravity=Center_Gravity-0.001;
      else if(Encoder_x<-10)Center_Gravity=Center_Gravity+0.001;	
      if(Encoder_x>20)Center_Gravity=Center_Gravity-0.002;
      else if(Encoder_x<-20)Center_Gravity=Center_Gravity+0.002;
      if(Encoder_x>30)Center_Gravity=Center_Gravity-0.005;
      else if(Encoder_x<-30)Center_Gravity=Center_Gravity+0.005;
		
     	Balance_Pwm_x=balance_x(Angle_Balance_x,Gyro_Balance_x);   //===角度PD控制	
			velocity_Pwm_x=velocity_x(Encoder_x);       //===速度PD控制
      Moto_x=Balance_Pwm_x+velocity_Pwm_x;        //===计算电机最终PWM			                    
}
int balance_x(float Angle,float gyro)//倾角PD控制 入口参数：角度 返回  值：倾角控制PWM
{  
	 float Balance_KP=450,Balance_KI=0,Balance_KD=4;
   float Bias; //倾角偏差
	 static float D_Bias,Integral_bias; //PID相关变量
	 int balance;   //PWM返回值 
	 Bias=Angle-Center_Gravity;   //求出平衡的角度中值 和机械相关
	 Integral_bias+=Bias;	
	 if(Integral_bias>30000)Integral_bias=30000;
	 if(Integral_bias<-30000)Integral_bias=-30000;
   D_Bias=gyro;	            //求出偏差的微分 进行微分控制
	 balance=Balance_KP*Bias+Balance_KI*Integral_bias+D_Bias*Balance_KD;   //===计算倾角控制的电机PWM  PD控制
	 return balance;
}
int velocity_x(int encoder) //位置式PID控制器 入口参数：编码器测量位置信息，目标位置  返回  值：电机PWM
{ 	
	 float Position_KP=-600,Position_KI=-0.5,Position_KD=0;
	 Encoder_L *= 0.65;		                                                //===一阶低通滤波器       
	 Encoder_L += encoder*0.35;	                                    //===一阶低通滤波器    
	 Integral_bias_L+=Encoder_L;	                                 //求出偏差的积分
	 if(Integral_bias_L>10000)Integral_bias_L=10000;
	 if(Integral_bias_L<-10000)Integral_bias_L=-10000;
	 
	 Pwm_L=Position_KP*Encoder_L+Position_KI*Integral_bias_L+Position_KD*(Encoder_L-Last_Bias_L);       //位置式PID控制器
	 Last_Bias_L=Encoder_L;                                       //保存上一次偏差 
	 return Pwm_L;                                           //增量输出
}
void Set_Pwm(int motox)
{
	  int Amplitude_x=7199;    //===PWM满幅是7200 限制在6900
	  if(motox<-Amplitude_x) motox=-Amplitude_x;	
		if(motox>Amplitude_x)  motox=Amplitude_x;	
	
    if(motox<0)			DIR=0;
		else 	          DIR=1;
		PWM=7199-myabs(motox);
}
int Incremental_PI (int Encoder,float Target)
{ 	
   float Kp=2,Ki=0.5;	
	 Bias=Encoder-Target;                //计算偏差
	 Pwm+=Kp*(Bias-Last_bias)+Ki*Bias;   //增量式PI控制器
	 Last_bias=Bias;	                   //保存上一次偏差 
	 return Pwm;                         //增量输出
}
int myabs(int a)
{ 		   
	  int temp;
		if(a<0)  temp=-a;  
	  else temp=a;
	  return temp;
}
void Get_Angle(void)
{ 
  u8 bufa[6],bufg[6];	
	float Accel_Y,Accel_X,Accel_Z,Gyro_Y,Gyro_X,Gyro_Z;
	MPU_Read_Len(MPU_ADDR,MPU_ACCEL_XOUTH_REG,6,bufa);
	MPU_Read_Len(MPU_ADDR,MPU_GYRO_XOUTH_REG,6,bufg);
	
 	sensor.acc.origin.x = ((((int16_t)bufa[0]) << 8) | bufa[1]);
 	sensor.acc.origin.y = ((((int16_t)bufa[2]) << 8) | bufa[3]);
 	sensor.acc.origin.z = ((((int16_t)bufa[4]) << 8) | bufa[5]);

 	sensor.gyro.origin.x = ((((int16_t)bufg[0]) << 8)| bufg[1]);
 	sensor.gyro.origin.y = ((((int16_t)bufg[2]) << 8)| bufg[3]);
 	sensor.gyro.origin.z = ((((int16_t)bufg[4]) << 8)| bufg[5]);	
		  
	Gyro_Y=sensor.gyro.origin.y;//读取X轴陀螺仪
	Gyro_Z=sensor.gyro.origin.z;    //读取Z轴陀螺仪
	Accel_X=sensor.acc.origin.x; //读取Y轴加速度计
	Accel_Z=sensor.acc.origin.z; //读取Z轴加速度计
	if(Gyro_Y>32768)  Gyro_Y-=65536;                       //数据类型转换  也可通过short强制类型转换
	if(Gyro_Z>32768)  Gyro_Z-=65536;                       //数据类型转换
	if(Accel_X>32768) Accel_X-=65536;                      //数据类型转换
	if(Accel_Z>32768) Accel_Z-=65536;                      //数据类型转换	
	//Gyro_Balance_y=-Gyro_Y;           //更新平衡角速度		
	Accel_Y=atan2(Accel_X,Accel_Z)*180/PI; //计算倾角	
  Gyro_Y=Gyro_Y/16.4;               //陀螺仪量程转换
	//Yijielvbo_Y(Accel_Y,-Gyro_Y);

			
	Gyro_X=sensor.gyro.origin.x;//读取X轴陀螺仪
	Accel_Y=sensor.acc.origin.y; //读取Y轴加速度计
	if(Gyro_X>32768)  Gyro_X-=65536;                       //数据类型转换  也可通过short强制类型转换
	if(Accel_Y>32768) Accel_Y-=65536;                      //数据类型转换
	Gyro_Balance_x=-Gyro_X;           //更新平衡角速度
	Accel_X= (atan2(Accel_Z , Accel_Y)) * 180 / PI; //计算倾角	
  Gyro_X=Gyro_X/16.4;               //陀螺仪量程转换			
	Yijielvbo_X(Accel_X,-Gyro_X);
}

